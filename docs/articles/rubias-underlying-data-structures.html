<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>An Explanation of the Underlying Data Structures in rubias • rubias</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="An Explanation of the Underlying Data Structures in rubias">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rubias</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/rubias-fully-bayesian.html">Using the Fully Bayesian Model in rubias</a></li>
    <li><a class="dropdown-item" href="../articles/rubias-overview.html">An Overview of rubias Usage</a></li>
    <li><a class="dropdown-item" href="../articles/rubias-underlying-data-structures.html">An Explanation of the Underlying Data Structures in rubias</a></li>
    <li><a class="dropdown-item" href="../articles/uncertainty-on-total-catch.html">Summarizing Uncertainty on Stock-Specific Total Catch</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/eriqande/rubias/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>An Explanation of the Underlying Data Structures in rubias</h1>
                        <h4 data-toc-skip class="author">Eric C.
Anderson</h4>
            
            <h4 data-toc-skip class="date">2025-10-16</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/eriqande/rubias/blob/HEAD/vignettes/rubias-underlying-data-structures.Rmd" class="external-link"><code>vignettes/rubias-underlying-data-structures.Rmd</code></a></small>
      <div class="d-none name"><code>rubias-underlying-data-structures.Rmd</code></div>
    </div>

    
    
<p>In order to be computationally efficient and allow for multiallelic
markers, with <code>rubias</code> we boil most of the data down to a
bunch of integer vectors in a data structure that we operate on with
some compiled code.</p>
<p>This document is intended to document that data structure (mostly for
Eric’s benefit, at this point. We should have had a document like this a
long time ago).</p>
<div class="section level2">
<h2 id="the-param_list">The <code>param_list</code><a class="anchor" aria-label="anchor" href="#the-param_list"></a>
</h2>
<p>The basic data structure is what we call a <code>param_list</code>.
it has the following named elements, which are briefly described here.
We will describe each in detail in separate sections below.</p>
<ul>
<li><p><code>L</code>: the number of loci, an integer</p></li>
<li><p><code>N</code>: the number of individuals (integer)<br></p></li>
<li><p><code>C</code>: the number of collections in the reference data
set (integer)</p></li>
<li><p><code>A</code>: the number of alleles at each locus (integer
vector of length L)</p></li>
<li><p><code>CA</code>: the “cumulative number of alleles” at each
locus. For each locus this gives the base-0 index of the first allele at
the locus (if you were to line all the alleles at each locus up one
after another.)</p></li>
<li><p><code>coll</code>: an integer vector of length N that gives the
index of the collection that each fish is in.</p></li>
<li><p><code>coll_N</code>: an integer vector of length C that gives the
number of fish in each of the collections</p></li>
<li><p><code>RU_vec</code>: This is the hardest one to figure out /
remember. Imagine that each collection has an index from 1 up to C, and
imagine that each collection belongs to a single reporting unit. Each
reporting unit is assigned an integer. Now, sort everything first by
reporting unit index and then by collection index. The order that you
get is the order of the collections in <code>RU_vec</code>. This vector
is a named integer vector. The collections are in the order as described
above. The names are the collection names and the values are the base-1
index of each collection.<br></p></li>
<li>
<p><code>RU_starts</code>: The base-0 index of the starting position
of each reporting unit in the <code>RU_vec</code> vector. This is a
named integer vector. For example, the first few entries of the chinook
data set are:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ploidies</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/check_refmix.html">check_refmix</a></span><span class="op">(</span><span class="va">chinook</span>, <span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">cpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tcf2param_list.html">tcf2param_list</a></span><span class="op">(</span><span class="va">chinook</span>, <span class="fl">5</span>, summ <span class="op">=</span> <span class="cn">FALSE</span>, ploidies <span class="op">=</span> <span class="va">ploidies</span><span class="op">)</span></span>
<span><span class="va">cpar</span><span class="op">$</span><span class="va">RU_starts</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span>
<span><span class="co">#&gt; CentralValleyfa CentralValleysp CentralValleywi CaliforniaCoast        KlamathR </span></span>
<span><span class="co">#&gt;               0               8              12              13              15</span></span></code></pre></div>
<p>and if we look at the first 15 elements of <code>RU_vec</code> it
gives us the names and the indices of the collections in those first 4
listed reporting units:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cpar</span><span class="op">$</span><span class="va">RU_vec</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">15</span><span class="op">]</span></span>
<span><span class="co">#&gt;         Feather_H_sp         Feather_H_fa          Butte_Cr_fa </span></span>
<span><span class="co">#&gt;                    1                    6                    7 </span></span>
<span><span class="co">#&gt;           Mill_Cr_fa           Deer_Cr_fa       Mokelumne_R_fa </span></span>
<span><span class="co">#&gt;                    8                    9                   10 </span></span>
<span><span class="co">#&gt;            Battle_Cr      Sacramento_R_lf          Butte_Cr_Sp </span></span>
<span><span class="co">#&gt;                   11                   12                    2 </span></span>
<span><span class="co">#&gt;           Mill_Cr_sp           Deer_Cr_sp UpperSacramento_R_sp </span></span>
<span><span class="co">#&gt;                    3                    4                    5 </span></span>
<span><span class="co">#&gt;         Sacramento_H                Eel_R            Russian_R </span></span>
<span><span class="co">#&gt;                   13                   14                   15</span></span></code></pre></div>
</li>
<li><p><code>I</code>: an integer vector giving the allelic type of each
gene copy carried by each individual. For ploidy = 2 (the only case
implemented so far) this vector is of length (N * L * 2). An entry of 0
denotes missing data, and the observed alleles are named 1, 2,
…</p></li>
<li><p><code>AC</code>: this is a flat integer vector of the counts of
alleles of different types in the different populations. It has length C
* sum(A) (i.e. the number of collections in the reference times that
total number of alleles at all the loci.). This is created by a somewhat
lengthy process: first the function
<code><a href="../reference/reference_allele_counts.html">reference_allele_counts()</a></code> makes a long data frame that has
<code>collection</code>, <code>locus</code>, <code>allele</code>, and
<code>counts</code>. This then gets turned into a list of matrices in
<code><a href="../reference/a_freq_list.html">a_freq_list()</a></code>. One matrix for each collection. The rows are
the different alleles and the columns are the different populations.
Then in <code><a href="../reference/list_diploid_params.html">list_diploid_params()</a></code> that list of matrices gets
flattened into one long integer vector.<br>
One of the weaknesses as I see that now, is that the loci are arranged
alphabetically, rather than by input order. We should at least include
the names of the loci in the order in which they appear so that we can
get back to the loci, if necessary. The order of the loci coming out of
this process is used to make sure that it corresponds to the order of
the loci in <code>I</code>, which is good, but not super intuitive. At
any rate, from the foregoing, it can be deduced that we can index into
this vector thus (all indexes are base-0): if we want the count of the
a-th allele at the l-th locus in the c-th collection then we get that by
base-0 subscipting <code>AC</code> by
<code>[C * CA[l] + c * A[l] + a].  Where</code>C<code>is the number of collections,</code>CA<code>is the cumulative number of alleles, and</code>A<code>is the number of alleles at each locus. Now it should be clear why we store</code>CA`—this
is where we use it!</p></li>
<li><p><code>sum_AC</code>: the sum of the allele counts at each locus
for each collection in the reference data set. (Basically the number of
observed gene copies at the locus in the reference data set). This gets
computed in <code><a href="../reference/list_diploid_params.html">list_diploid_params()</a></code> from the list of matrices
returned by <code><a href="../reference/a_freq_list.html">a_freq_list()</a></code>. It is of length L * C. It is a
named vector with the names taking <code>Locus.Collection</code>, but I
don’t think those names get used at all. It gets indexed as
<code>[l * C + c]</code></p></li>
<li><p><code>DP</code>: this is a vector completely parallel to
<code>AC</code> but in which the prior weights have been added to each
allele in each collection.<br></p></li>
<li><p><code>sum_DP</code>: this is the sum of Dirichlet Parameters
<code>DP</code> for each locus and each collection. It is parallel to
<code>sum_AC</code>.</p></li>
</ul>
<p>Finally, we have some entries that we should have had from day one,
but didn’t, so they aren’t consistently used throughout the code to
access the names of entities ordered as they ended up ordered: -
<code>indiv_names</code> - <code>collection_names</code> -
<code>repunit_names</code> - <code>locus_names</code></p>
</div>
<div class="section level2">
<h2 id="howwhere-do-all-these-get-set">How/Where do all these get set?<a class="anchor" aria-label="anchor" href="#howwhere-do-all-these-get-set"></a>
</h2>
<p>This is a trickier question than it seems, because things are done
slightly differently in the different top-level functions.</p>
<div class="section level3">
<h3 id="assess_reference_loo-and-assess_reference_mc">assess_reference_loo() and assess_reference_mc()<a class="anchor" aria-label="anchor" href="#assess_reference_loo-and-assess_reference_mc"></a>
</h3>
<p>In both of these functions, the original data sets gets read in,
collection and repunit get converted to factors, and then the
<code>param_list</code> is made inside a single function:
<code><a href="../reference/tcf2param_list.html">tcf2param_list()</a></code>.</p>
</div>
<div class="section level3">
<h3 id="assess_pb_bias_correction">assess_pb_bias_correction()<a class="anchor" aria-label="anchor" href="#assess_pb_bias_correction"></a>
</h3>
<p>Same as above, this uses <code><a href="../reference/tcf2param_list.html">tcf2param_list()</a></code> after doing a
few other steps on the original data frame.</p>
</div>
<div class="section level3">
<h3 id="self_assign">self_assign()<a class="anchor" aria-label="anchor" href="#self_assign"></a>
</h3>
<p>Uses <code><a href="../reference/tcf2param_list.html">tcf2param_list()</a></code> unless it is using
preCompiledParams so that it can run through stuff during infer_mixture
to compute the locus-specific means and variances of the
log-likelihoods.</p>
</div>
<div class="section level3">
<h3 id="infer_mixture">infer_mixture()<a class="anchor" aria-label="anchor" href="#infer_mixture"></a>
</h3>
<p>This is the tough one. Because we end up doing multiple mixture
collections, we couldn’t simply use <code><a href="../reference/tcf2param_list.html">tcf2param_list()</a></code> in the
function. Rather, we create a summary for the reference sample (keeping
track of alleles found in both the reference and the mixture), and then
we split the mixture samples up by mixture collection and use</p>
</div>
</div>
<div class="section level2">
<h2 id="dealing-with-012-matrices">Dealing with 012 matrices<a class="anchor" aria-label="anchor" href="#dealing-with-012-matrices"></a>
</h2>
<p>One problem with the current approach is that it is terribly slow
when you start to get 10K+ SNPs. It would be much faster to read and
store those data in an 012 matrix. Here is how I am thinking I could
deal with that:</p>
<ul>
<li>
<p>For the functions that use <code><a href="../reference/tcf2param_list.html">tcf2param_list()</a></code> I could
just write another function, <code>tcf2param_list_012()</code>, that
took <code>D</code> as just a data frame with <code>sample_type</code>,
<code>collection</code>, and <code>repunit</code> and
<code>indiv</code>, and then had an 012 matrix with the genetic data in
it, with indiv names in the rownames and locus names in the colnames.
Then we just have to deal with seeing AC_list and I_list correctly.
<em>Actually</em>, looking at it now, I can just do it in the same
<code><a href="../reference/tcf2param_list.html">tcf2param_list()</a></code> function. If the <code>d012</code>
parameter is not NULL we would:</p>
<ol style="list-style-type: decimal">
<li>make <code>cleaned$long</code> NULL, and set
<code>cleaned$clean_short</code> to <code>D</code>.</li>
<li>make the <code>AC_list</code> directly from the 012 matrix. This
should be super straightforward. I would probably want to drop
monomorphic loci first.</li>
<li>make the I_list from the 012 matrix</li>
</ol>
</li>
</ul>
<p>Cool, in order to do all this I should make two new functions:
<code>reference_allele_counts_012</code> and
<code>allelic_list_012</code>. That might give me enough insight that I
could easily do it for <code>infer_mixture</code>, too.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Eric C. Anderson, Ben Moran.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
