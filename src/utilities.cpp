#include <Rcpp.h>
using namespace Rcpp;

// Some simple utilities for Rcpp


double rgammadouble(int a, double b, double c)
{   Rcpp::NumericVector x = rgamma(a,b,1/c);
  return x(0);
}

// Given a maximum integer n, simulates an integer from 1:n
int randint(int n) {
  if(n == 0) {
    return(0);
  }
  int ind;
  double rando;
  rando = runif(1)[0];
  ind = ceil(rando * n);
  return(ind);
}

//' Given a vector of different categories in 1...n and a prior,
//' simulate a Dirichlet random vector
//'
//' Takes a vector of collection indices to which individuals (vector elements) were assigned,
//' and returns a Dirichlet random variable generated by adding the prior to the sum
//' of each collection's occurrences, and simulating an alpha from a gamma distribution
//' with this shape parameter.
//'
//' The categories are labeled in C from 1 up to n.  n is the length of \code{lambda},
//' which is a vector of priors. Note that all elements of \code{lambda}
//' must be strictly greater than 0.
//'
//' @keywords internal
//'
//' @param C  a vector giving different categories of individual
//' (not counts of categories - untabulated)
//' @param lambda priors for the categories
//' @export
// [[Rcpp::export]]
NumericVector dirch_from_allocations(IntegerVector C, NumericVector lambda) {
  int i;
  int n = lambda.size();
  int N = C.size();
  NumericVector out = clone(lambda);

  for(i = 0; i < N; i++) {
    out[C[i] - 1] += 1.0;
  }
  for(i = 0; i < n; i++) {
    out[i] = rgammadouble(1L, out[i], 1.0);
  }

  return(out / sum(out));
}

//' Given a vector of counts for different categories in 1...n and a prior,
//' simulate a Dirichlet random vector
//'
//' Takes a vector of counts for 1:n collections,
//' and returns a Dirichlet random variable generated by adding the prior to each
//' collection value, and simulating an alpha from a gamma distribution
//' with this shape parameter.
//'
//' The categories are labeled in C from 1 up to n.  n is the length of \code{lambda},
//' which is a vector of priors. Note that all elements of \code{lambda}
//' must be strictly greater than 0.
//' @keywords internal
//' @param C  a vector giving counts of categories
//' @param lambda priors for the categories
//' @export
// [[Rcpp::export]]
NumericVector dirch_from_counts(IntegerVector C, NumericVector lambda) {
  int i;
  int n = lambda.size();
  NumericVector out = clone(lambda);

  for(i = 0; i < n; i++) {
    out[i] += C[i];
  }
  for(i = 0; i < n; i++) {
    out[i] = rgammadouble(1L, out[i], 1.0);
  }

  return(out / sum(out));
}



//' Given a vector of n different categories in 1...n, count up their occurrences and return in a vector of length n
//'
//' I should have written this for the other functions above, but I am just getting to it now
//' to sum up the Zeds of the fish for the total catch sampling stuff.  This is set up so
//' that if any of the fish have -1 they are skipped.  This lets us use it for
//' variable_catch_is_prob == TRUE situations.
//' @keywords internal
//' @param C a vector of categories taking values of 1,...,n
//' @param n the number of categories
//' @export
// [[Rcpp::export]]
IntegerVector tabulate_allocations(IntegerVector C, int n) {
  int i;
  int N = C.size();  // number of zeds
  IntegerVector out(n, 0);  // explicitly initialize to zeroes

  for(i = 0; i < N; i++) {
    if(C[i] != -1) out[C[i] - 1] += 1;
  }

  return(out);
}


//' Simulate whether fish are part of the catch or not
//'
//' This is for the variable_prob_is_catch == TRUE scenario. We simply
//' go through the vector Z of allocations. For each one, we simulate
//' a uniform RV.  If that RV is greater than the corresponding term
//' in P, then we turn that Z into a -1, so it will not be counted by
//' tabulate_allocations().  NC returns the number that are part of the
//' catch by reference.
//' @keywords internal
 //' @param Z a vector of categories taking values of 1,...,n
 //' @param P probabilities of being considered "catch" for each of the mixure samples
 //' @param NC output by reference of the number of fish considered to actually be catch.
 //' @export
 // [[Rcpp::export]]

 IntegerVector turn_non_catch_to_minus_one(IntegerVector Z, NumericVector P, int &NC) {
   int N = Z.size();
   IntegerVector out(N, 0);
   NC = 0;

   for (int i = 0; i < N; i++) {
     double rando = runif(1)[0];
     if (rando > P[i]) {
       out[i] = -1;
     } else {
       out[i] = Z[i];
       NC++;
     }
   }

   return out;
 }
